#define TRACE_LENGTH    136
#define	LATCH_TOLERANCE	90

object tdm_latch
{
	void init();
	void frobabilityLoop();
	boolean areDoorsOpen();
	boolean areDoorsLocked();
	void setDoorsFrobable(float frobable);
	void setDoorsAINotHandle(float value);
	void lockDoors(float lock);
	boolean checkTolerance();
	boolean checkObstruction();
	void frobResponse();
	void moveLatch(float latchState);

	float latchState;	//1 = open, 0 = closed
};

void tdm_latch::init()
{

	if ( areDoorsOpen() || !areDoorsLocked() )
	{
		latchState = 1;
		thread moveLatch(latchState);
	}

	//start checking whether the player is allowed to frob the latch
	thread frobabilityLoop();
}

void tdm_latch::frobabilityLoop()
{
	vector latchPos = getWorldOrigin();
	setFrobable(0);

	while(1)
	{
		sys.wait(0.2);
		if( sys.vecLength($player1.getEyePos() - latchPos ) > TRACE_LENGTH )
			continue;    //skip if the player is too far away

		//player either has to be on the right side of the door or be able to reach through to the latch for it to be frobable

		// TODO this was split up to add debug - condense later
		float frobable = checkTolerance() || checkObstruction();
		
		if ( areDoorsOpen() )
		{
			setFrobable( 0 );
		}
		else
		{
			setFrobable( frobable );
		}

		// Set the door frobability
		if ( latchState )
		{
			// If the latch is opening, wait until it's
			// done before changing frobability
			while ( isMoving() )
			{
				sys.wait( 0.1 );
			}
			
			// always frobable when latch is open
			setDoorsFrobable( 1 );
		}
		else 
		{
			// When latch is closed, depends on player position checks above
			setDoorsFrobable( !frobable );
		}
	}
}

boolean tdm_latch::areDoorsOpen()
{
	float i;

	for(i = 0; i < numTargets(); i++)
	{
		entity e = getTarget(i);

		if( e.getKey("spawnclass") == "CFrobDoor" )
		{
			if ( e.IsOpen() )
				return true;
		}
	}
	return false;
}

boolean tdm_latch::areDoorsLocked()
{
	float i;

	for(i = 0; i < numTargets(); i++)
	{
		entity e = getTarget(i);

		if( e.getIntKey("locked") )
		{
				return true;
		}
	}
	return false;
}

void tdm_latch::setDoorsFrobable(float frobable)
{
	float i;

	for(i = 0; i < numTargets(); i++)
	{
		entity e = getTarget(i);

		if( e.getKey("spawnclass") == "CFrobDoor" )
		{
			e.setFrobable(frobable);
		}
	}
}

void tdm_latch::setDoorsAINotHandle(float value)
{
	float i;

	for(i = 0; i < numTargets(); i++)
	{
		entity e = getTarget(i);

		if( e.getKey("spawnclass") == "CFrobDoor" )
		{
			e.setKey( "ai_should_not_handle", value );
		}
	}
}

// 1: lock doors
// 0: unlock doors
void tdm_latch::lockDoors(float lock)
{
	float i;

	for(i = 0; i < numTargets(); i++)
	{
		entity e = getTarget(i);

		if( e.getKey("spawnclass") == "CFrobDoor" )
		{
			if (lock)
			{
				// being defensive here - only lock if unlocked
				if ( !e.IsLocked() )
				{
					e.Lock();
				}
			}
			else
			{
				// If you unlock the door when it's already unlocked, the door will open
				// if 'open doors on unlock' is enabled in the game settings.
				if ( e.IsLocked() )
				{
					e.Unlock();
				}
			}
		}
	}
}

boolean tdm_latch::checkObstruction()
{
	vector TraceDir     = sys.vecNormalize( $player1.getViewAngles() );
	vector TraceRadius  = getVectorKey("trace_radius");    //as a vector
	vector TraceStart   = $player1.getEyePos();
	vector TraceEnd     = TraceStart + TraceDir * TRACE_LENGTH;

	//check whether there is a clear line from the player's eyes to the latch
	float TraceResult    = sys.trace( TraceStart, TraceEnd, -TraceRadius, TraceRadius, CONTENTS_SOLID, self );


	if( TraceResult == 1 )
	{
		return true;    //clear line
	}


	else if( sys.getTraceEntity().getBindMaster() == self )
	{
		return true;    //trace has hit something that's bound to the latch
	}

	else
	{
		return false;    //line is obstructed by something else
	}

}

boolean tdm_latch::checkTolerance()
{
	vector LatchNormal = getVectorKey( "latch_normal" );
	vector AngToPlayer = sys.VecToAngles( $player1.getOrigin() - getWorldOrigin() );

	//check whether the player is standing within the latch tolerance
	float length = sys.vecLength( anglemod180(AngToPlayer - LatchNormal)  );
	return ( length < LATCH_TOLERANCE );
}


void tdm_latch::frobResponse()
{
	if( isMoving() || isRotating() )
		return;

	latchState = !latchState;

	thread moveLatch(latchState);
}

void tdm_latch::moveLatch(float latchState)
{
	time( getFloatKey("move_time") );
	moveToPos( getVectorKey("origin") + latchState * getVectorKey("translate") );
	rotateOnce( (2*latchState - 1) * getVectorKey("rotate") );

	startSound( "snd_move", SND_CHANNEL_ANY, false);

	sys.wait( getFloatKey("move_time") );

	if (latchState)
	{
		lockDoors( 0 );
	}
	else
	{
		lockDoors( 1 );
	}

	setDoorsFrobable( latchState );
	setDoorsAINotHandle( !latchState );
}