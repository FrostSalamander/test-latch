#define TRACE_LENGTH    136
#define	LATCH_TOLERANCE	90

object tdm_latch
{
	void init();
	void frobabilityLoop();
	boolean areDoorsOpen();
	boolean areDoorsLocked();
	void setDoorsFrobable(float frobable);
	void setDoorsAINotHandle(float value);
	void lockDoors();
	void unlockDoors();
	void setDoorsLockState(float lock);
	void frobResponse();
	void moveLatch(float latchState);
	void rotateLatch();
	void translateLatch();

	float latchState;	//1 = open, 0 = closed
};

void tdm_latch::init()
{

	if ( areDoorsOpen() || !areDoorsLocked() )
	{
		latchState = 1;
		thread moveLatch(latchState);
	}

	//start checking whether the player is allowed to frob the latch
	thread frobabilityLoop();
}

void tdm_latch::frobabilityLoop()
{
	vector latchPos = getWorldOrigin();
	setFrobable(0);

	while(1)
	{
		sys.wait(0.2);

		if ( ( sys.vecLength($player1.getEyePos() - latchPos ) > TRACE_LENGTH ) )
			continue;    //skip if the player is too far away

		// if player is in same location as the latch, make it frobable
		float frobable = ( getLocation() == $player1.getLocation() );
		
		if ( areDoorsOpen() && latchState )
		{
			setFrobable( 0 );
		}
		else
		{
			setFrobable( frobable );
		}

		sys.println( self.getName() + ": frobable: " + isFrobable() );

		// Set the door frobability
		if ( latchState )
		{
			// If the latch is opening, wait until it's
			// done before changing frobability
			while ( isMoving() )
			{
				sys.wait( 0.1 );
			}
			
			// always frobable when latch is open
			setDoorsFrobable( 1 );
		}
		else 
		{
			// When latch is closed, depends on player position checks above
			setDoorsFrobable( !frobable );
		}
	}
}

boolean tdm_latch::areDoorsOpen()
{
	float i;

	for(i = 0; i < numTargets(); i++)
	{
		entity e = getTarget(i);

		if( e.getKey("spawnclass") == "CFrobDoor" )
		{
			if ( e.IsOpen() )
				return true;
		}
	}
	return false;
}

boolean tdm_latch::areDoorsLocked()
{
	float i;

	for(i = 0; i < numTargets(); i++)
	{
		entity e = getTarget(i);

		if( e.getIntKey("locked") )
		{
				return true;
		}
	}
	return false;
}

void tdm_latch::setDoorsFrobable(float frobable)
{
	float i;

	for(i = 0; i < numTargets(); i++)
	{
		entity e = getTarget(i);

		if( e.getKey("spawnclass") == "CFrobDoor" )
		{
			e.setFrobable(frobable);
		}
	}
}

void tdm_latch::setDoorsAINotHandle(float value)
{
	float i;

	for(i = 0; i < numTargets(); i++)
	{
		entity e = getTarget(i);

		if( e.getKey("spawnclass") == "CFrobDoor" )
		{
			e.setKey( "ai_should_not_handle", value );
		}
	}
}

void tdm_latch::lockDoors()
{
	setDoorsLockState(1);
}

void tdm_latch::unlockDoors()
{
	setDoorsLockState(0);
}

// 1: lock doors
// 0: unlock doors
void tdm_latch::setDoorsLockState(float lock)
{
	float i;

	for(i = 0; i < numTargets(); i++)
	{
		entity e = getTarget(i);

		if( e.getKey("spawnclass") == "CFrobDoor" )
		{
			if (lock)
			{
				// being defensive here - only lock if unlocked
				if ( !e.IsLocked() )
				{
					e.Lock();
				}
			}
			else
			{
				// If you unlock the door when it's already unlocked, the door will open
				// if 'open doors on unlock' is enabled in the game settings.
				if ( e.IsLocked() )
				{
					e.Unlock();
				}
			}
		}
	}
}

void tdm_latch::frobResponse()
{
	if( isMoving() || isRotating() )
		return;

	latchState = !latchState;

	thread moveLatch(latchState);
}

void tdm_latch::moveLatch(float latchState)
{
	time( getFloatKey("move_time") );

	// if latch is opening, rotate then translate.  Reverse if latch is closing.
	if ( latchState )
	{
		// immediately set the latch to unfrobable instead of relying on the loop to 
		// prevent player from moving it and locking the door in open position
		setFrobable(0);

		sys.println("Frobable after frob: " + isFrobable());

		rotateLatch();

		while ( isRotating() )
		{
			sys.wait( 0.2 );
		}

		translateLatch();
	}
	else
	{
		translateLatch();

		while ( isMoving() )
		{
			sys.wait( 0.2 );
		}

		rotateLatch();
	}

	sys.wait( getFloatKey("move_time") );

	if (latchState)
	{
		unlockDoors();
	}
	else
	{
		lockDoors();
	}

	setDoorsFrobable( latchState );
	setDoorsAINotHandle( !latchState );
}

void tdm_latch::rotateLatch()
{
	startSound( "snd_rotate", SND_CHANNEL_ANY, false);
	rotateOnce( (2*latchState - 1) * getVectorKey("rotate") );
}

void tdm_latch::translateLatch()
{
	startSound( "snd_translate", SND_CHANNEL_ANY, false);
	moveToPos( getVectorKey("origin") + latchState * getVectorKey("translate") );
}